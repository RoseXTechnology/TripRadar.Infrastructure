name: Infrastructure - Terraform

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment for deployment'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      action:
        description: 'Terraform operation to execute'
        required: true
        default: 'plan'
        type: choice
        options:
        - validate
        - plan
        - apply
        - destroy
      auto_approve:
        description: 'Auto-approve apply/destroy operations'
        required: false
        default: false
        type: boolean
      target_resources:
        description: 'Target specific resources (optional)'
        required: false
        type: string

env:
  # Azure Authentication (OIDC)
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  ARM_USE_OIDC: true
  ARM_SKIP_PROVIDER_REGISTRATION: true
  
  # Terraform Configuration
  TF_VERSION: "1.9.8"
  TF_WORKING_DIR: infra/terraform/environments/${{ inputs.environment }}/app
  TF_VAR_FILE: ../terraform.tfvars
  TF_LOG_LEVEL: INFO
  
  # Backend Configuration (Environment Independent)
  TF_BACKEND_RESOURCE_GROUP: "tripradar-tfstate-rg"
  TF_BACKEND_STORAGE_ACCOUNT: "tripradartfstate250825"
  TF_BACKEND_CONTAINER: "tfstate"
  
  # Pipeline Configuration
  AZURE_LOCATION: "northeurope"
  PROJECT_NAME: "tripradar"

jobs:
  # ==============================================================================
  # VALIDATION JOB - Validate inputs and environment prerequisites
  # ==============================================================================
  validate-environment:
    name: üîç Validate Environment & Prerequisites
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.validate.outputs.environment }}
      resource_group_name: ${{ steps.validate.outputs.resource_group_name }}
      terraform_key: ${{ steps.validate.outputs.terraform_key }}
      
    steps:
      - name: üìã Validate Pipeline Inputs
        id: validate
        run: |
          # Validate environment input
          case "${{ inputs.environment }}" in
            dev|staging|prod)
              echo "‚úÖ Environment '${{ inputs.environment }}' is valid"
              ;;
            *)
              echo "‚ùå Invalid environment: ${{ inputs.environment }}"
              exit 1
              ;;
          esac
          
          # Validate action input
          case "${{ inputs.action }}" in
            validate|plan|apply|destroy)
              echo "‚úÖ Action '${{ inputs.action }}' is valid"
              ;;
            *)
              echo "‚ùå Invalid action: ${{ inputs.action }}"
              exit 1
              ;;
          esac
          
          # Set outputs
          echo "environment=${{ inputs.environment }}" >> $GITHUB_OUTPUT
          echo "resource_group_name=${{ env.PROJECT_NAME }}-${{ inputs.environment }}-rg" >> $GITHUB_OUTPUT
          echo "terraform_key=${{ env.PROJECT_NAME }}-${{ inputs.environment }}.tfstate" >> $GITHUB_OUTPUT
          
          # Validate auto-approve usage
          if [[ "${{ inputs.auto_approve }}" == "true" && "${{ inputs.environment }}" == "prod" ]]; then
            echo "‚ö†Ô∏è WARNING: Auto-approve enabled for production environment"
            if [[ "${{ inputs.action }}" == "destroy" ]]; then
              echo "‚ùå Auto-approve destroy operations are not allowed in production"
              exit 1
            fi
          fi

  # ==============================================================================
  # INFRASTRUCTURE SETUP JOB - Setup backend storage and authentication
  # ==============================================================================  
  setup-infrastructure:
    name: üèóÔ∏è Setup Infrastructure Foundation
    runs-on: ubuntu-latest
    needs: [validate-environment]
    permissions:
      id-token: write
      contents: read
    outputs:
      backend_configured: ${{ steps.backend.outputs.configured }}
      
    steps:
      - name: üîÑ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: üîê Authenticate with Azure (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ env.ARM_CLIENT_ID }}
          tenant-id: ${{ env.ARM_TENANT_ID }}
          subscription-id: ${{ env.ARM_SUBSCRIPTION_ID }}
          
      - name: üîç Validate Azure Connectivity
        run: |
          echo "üîç Validating Azure connectivity and permissions..."
          
          # Check Azure CLI authentication
          if ! az account show --query "id" -o tsv >/dev/null 2>&1; then
            echo "‚ùå Azure authentication failed"
            exit 1
          fi
          
          SUBSCRIPTION_ID=$(az account show --query "id" -o tsv)
          echo "‚úÖ Authenticated to subscription: $SUBSCRIPTION_ID"
          
          # Validate subscription matches expected
          if [[ "$SUBSCRIPTION_ID" != "${{ env.ARM_SUBSCRIPTION_ID }}" ]]; then
            echo "‚ùå Subscription mismatch. Expected: ${{ env.ARM_SUBSCRIPTION_ID }}, Got: $SUBSCRIPTION_ID"
            exit 1
          fi
          
      - name: üóÑÔ∏è Setup Terraform Backend Storage
        id: backend
        run: |
          echo "üóÑÔ∏è Configuring Terraform backend storage..."
          
          # Check if backend resource group exists
          if ! az group show --name "${{ env.TF_BACKEND_RESOURCE_GROUP }}" >/dev/null 2>&1; then
            echo "üì¶ Creating backend resource group: ${{ env.TF_BACKEND_RESOURCE_GROUP }}"
            az group create \
              --name "${{ env.TF_BACKEND_RESOURCE_GROUP }}" \
              --location "${{ env.AZURE_LOCATION }}" \
              --tags \
                "Project=${{ env.PROJECT_NAME }}" \
                "Purpose=TerraformState" \
                "Environment=shared" \
                "ManagedBy=GitHubActions"
          else
            echo "‚úÖ Backend resource group exists: ${{ env.TF_BACKEND_RESOURCE_GROUP }}"
          fi
          
          # Check if backend storage account exists
          if ! az storage account show \
            --name "${{ env.TF_BACKEND_STORAGE_ACCOUNT }}" \
            --resource-group "${{ env.TF_BACKEND_RESOURCE_GROUP }}" >/dev/null 2>&1; then
            echo "üíæ Creating backend storage account: ${{ env.TF_BACKEND_STORAGE_ACCOUNT }}"
            az storage account create \
              --resource-group "${{ env.TF_BACKEND_RESOURCE_GROUP }}" \
              --name "${{ env.TF_BACKEND_STORAGE_ACCOUNT }}" \
              --location "${{ env.AZURE_LOCATION }}" \
              --sku "Standard_LRS" \
              --kind "StorageV2" \
              --allow-blob-public-access false \
              --https-only true \
              --min-tls-version "TLS1_2" \
              --tags \
                "Project=${{ env.PROJECT_NAME }}" \
                "Purpose=TerraformState" \
                "Environment=shared" \
                "ManagedBy=GitHubActions"
          else
            echo "‚úÖ Backend storage account exists: ${{ env.TF_BACKEND_STORAGE_ACCOUNT }}"
          fi
          
          # Check if backend container exists
          if ! az storage container show \
            --name "${{ env.TF_BACKEND_CONTAINER }}" \
            --account-name "${{ env.TF_BACKEND_STORAGE_ACCOUNT }}" \
            --auth-mode login >/dev/null 2>&1; then
            echo "üìÇ Creating backend container: ${{ env.TF_BACKEND_CONTAINER }}"
            az storage container create \
              --account-name "${{ env.TF_BACKEND_STORAGE_ACCOUNT }}" \
              --name "${{ env.TF_BACKEND_CONTAINER }}" \
              --auth-mode login
          else
            echo "‚úÖ Backend container exists: ${{ env.TF_BACKEND_CONTAINER }}"
          fi
          
          echo "configured=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Terraform backend storage is ready"

  # ==============================================================================
  # TERRAFORM OPERATIONS JOB - Main infrastructure operations
  # ==============================================================================
  terraform-operations:
    name: üèóÔ∏è Terraform ${{ inputs.action }} (${{ inputs.environment }})
    runs-on: ubuntu-latest
    needs: [validate-environment, setup-infrastructure]
    environment: ${{ inputs.environment }}
    permissions:
      id-token: write
      contents: read
    outputs:
      api_url: ${{ steps.outputs.outputs.api_url }}
      deployment_status: ${{ steps.apply.outputs.status || steps.plan.outputs.status || steps.destroy.outputs.status }}
      
    steps:
      - name: üîÑ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: üîß Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false
          
      - name: üîê Authenticate with Azure (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ env.ARM_CLIENT_ID }}
          tenant-id: ${{ env.ARM_TENANT_ID }}
          subscription-id: ${{ env.ARM_SUBSCRIPTION_ID }}
          
      - name: ‚öôÔ∏è Initialize Terraform Backend
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "‚öôÔ∏è Initializing Terraform with remote backend..."
          terraform init \
            -backend-config="resource_group_name=${{ env.TF_BACKEND_RESOURCE_GROUP }}" \
            -backend-config="storage_account_name=${{ env.TF_BACKEND_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=${{ env.TF_BACKEND_CONTAINER }}" \
            -backend-config="key=${{ needs.validate-environment.outputs.terraform_key }}" \
            -no-color
            
      - name: üîß Handle Legacy Database State
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "üîß Checking for legacy database state issues..."
          
          # Check if database resource exists in state
          if terraform state list | grep -q "^module.app.azurerm_postgresql_flexible_server_database.tripradar\\[0\\]$"; then
            CURRENT_DB_ID=$(terraform state show -no-color "module.app.azurerm_postgresql_flexible_server_database.tripradar[0]" 2>/dev/null | awk -F' = ' '/^id = /{print $2; exit}' || echo "")
            
            # Check if it's a system database
            if echo "$CURRENT_DB_ID" | grep -E "(azure_sys|azure_maintenance|postgres)$"; then
              DB_NAME=$(echo "$CURRENT_DB_ID" | sed 's|.*/databases/||')
              echo "‚ö†Ô∏è Removing system database '$DB_NAME' from Terraform state"
              terraform state rm "module.app.azurerm_postgresql_flexible_server_database.tripradar[0]" || true
              
              # Import correct application database
              echo "üîÑ Importing correct application database..."
              RG_NAME="${{ needs.validate-environment.outputs.resource_group_name }}"
              PG_NAME=$(az postgres flexible-server list -g "$RG_NAME" --query "[0].name" -o tsv 2>/dev/null || true)
              if [ -n "$PG_NAME" ]; then
                APP_DB_NAME=$(az postgres flexible-server db list -g "$RG_NAME" -s "$PG_NAME" --query "[?name!='postgres' && name!='azure_maintenance' && name!='azure_sys']|[0].name" -o tsv 2>/dev/null || true)
                if [ -n "$APP_DB_NAME" ]; then
                  echo "‚úÖ Importing application database: $APP_DB_NAME"
                  terraform import -var-file="${{ env.TF_VAR_FILE }}" \
                    "module.app.azurerm_postgresql_flexible_server_database.tripradar[0]" \
                    "/subscriptions/${{ env.ARM_SUBSCRIPTION_ID }}/resourceGroups/${RG_NAME}/providers/Microsoft.DBforPostgreSQL/flexibleServers/${PG_NAME}/databases/${APP_DB_NAME}" || true
                fi
              fi
            else
              echo "‚úÖ Database state appears correct: $CURRENT_DB_ID"
            fi
          fi
          
      - name: üì• Import Existing Resources
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "üì• Importing existing Azure resources to prevent conflicts..."
          
          RG_NAME="${{ needs.validate-environment.outputs.resource_group_name }}"
          SUB="/subscriptions/${{ env.ARM_SUBSCRIPTION_ID }}"
          VAR_FILE="${{ env.TF_VAR_FILE }}"
          
          # Reusable import function with error handling
          import_resource() {
            local tf_address="$1"
            local azure_resource_id="$2"
            local resource_name="$3"
            
            if terraform state list | grep -q "^${tf_address}$"; then
              echo "‚è≠Ô∏è  ${resource_name}: Already in state"
              return 0
            fi
            
            if [ -z "$azure_resource_id" ]; then
              echo "‚è≠Ô∏è  ${resource_name}: Resource not found in Azure"
              return 0
            fi
            
            echo "üì• ${resource_name}: Importing..."
            if terraform import -var-file="$VAR_FILE" "$tf_address" "$azure_resource_id" 2>/dev/null; then
              echo "‚úÖ ${resource_name}: Import successful"
            else
              echo "‚ö†Ô∏è  ${resource_name}: Import failed (may not exist or already managed)"
            fi
          }
          
          # Import Resource Group
          import_resource "module.app.azurerm_resource_group.rg" \
                          "${SUB}/resourceGroups/${RG_NAME}" \
                          "Resource Group"
          
          # Import PostgreSQL Server
          PG_NAME=$(az postgres flexible-server list -g "$RG_NAME" --query "[0].name" -o tsv 2>/dev/null || true)
          if [ -n "$PG_NAME" ]; then
            import_resource "module.app.azurerm_postgresql_flexible_server.pg[0]" \
                            "${SUB}/resourceGroups/${RG_NAME}/providers/Microsoft.DBforPostgreSQL/flexibleServers/${PG_NAME}" \
                            "PostgreSQL Server"
          fi
          
          # Import Managed Identities
          for service in api jobs db; do
            MI_NAME="${{ env.PROJECT_NAME }}-${{ inputs.environment }}-${service}-mi"
            if az identity show -g "$RG_NAME" -n "$MI_NAME" >/dev/null 2>&1; then
              import_resource "module.app.azurerm_user_assigned_identity.${service}" \
                              "${SUB}/resourceGroups/${RG_NAME}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/${MI_NAME}" \
                              "Managed Identity ($service)"
            fi
          done
          
          # Import Log Analytics Workspace
          LAW_NAME=$(az monitor log-analytics workspace list -g "$RG_NAME" --query "[0].name" -o tsv 2>/dev/null || true)
          if [ -n "$LAW_NAME" ]; then
            import_resource "module.app.azurerm_log_analytics_workspace.law[0]" \
                            "${SUB}/resourceGroups/${RG_NAME}/providers/Microsoft.OperationalInsights/workspaces/${LAW_NAME}" \
                            "Log Analytics Workspace"
          fi
          
          # Import Container Registry
          ACR_NAME=$(az acr list -g "$RG_NAME" --query "[0].name" -o tsv 2>/dev/null || true)
          if [ -n "$ACR_NAME" ]; then
            import_resource "module.app.azurerm_container_registry.acr[0]" \
                            "${SUB}/resourceGroups/${RG_NAME}/providers/Microsoft.ContainerRegistry/registries/${ACR_NAME}" \
                            "Container Registry"
          fi
          
          # Import Key Vault
          KV_NAME=$(az keyvault list -g "$RG_NAME" --query "[0].name" -o tsv 2>/dev/null || true)
          if [ -n "$KV_NAME" ]; then
            import_resource "module.app.azurerm_key_vault.kv[0]" \
                            "${SUB}/resourceGroups/${RG_NAME}/providers/Microsoft.KeyVault/vaults/${KV_NAME}" \
                            "Key Vault"
          fi
          
          # Import Application Insights
          EXPECTED_APPI="${RG_NAME%-rg}-appi"
          if az monitor app-insights component show -g "$RG_NAME" -a "$EXPECTED_APPI" >/dev/null 2>&1; then
            APPI_NAME="$EXPECTED_APPI"
          else
            APPI_NAME=$(az monitor app-insights component list -g "$RG_NAME" --query "[0].name" -o tsv 2>/dev/null || true)
          fi
          
          if [ -n "$APPI_NAME" ]; then
            import_resource "module.app.azurerm_application_insights.appi[0]" \
                            "${SUB}/resourceGroups/${RG_NAME}/providers/Microsoft.Insights/components/${APPI_NAME}" \
                            "Application Insights"
          fi
          
          # Import Container Apps Environment
          CAE_NAME=$(az containerapp env list -g "$RG_NAME" --query "[0].name" -o tsv 2>/dev/null || true)
          if [ -n "$CAE_NAME" ]; then
            import_resource "module.app.azurerm_container_app_environment.cae[0]" \
                            "${SUB}/resourceGroups/${RG_NAME}/providers/Microsoft.App/managedEnvironments/${CAE_NAME}" \
                            "Container Apps Environment"
                            
            # Import Container Apps
            for CA_NAME in $(az containerapp list -g "$RG_NAME" --query "[].name" -o tsv 2>/dev/null || true); do
              CA_ID=$(az containerapp show -g "$RG_NAME" -n "$CA_NAME" --query id -o tsv 2>/dev/null || true)
              case "$CA_NAME" in
                *-api)
                  import_resource "module.app.module.ca_api[0].azurerm_container_app.this" \
                                  "$CA_ID" \
                                  "Container App (API)"
                  ;;
                *-jobs)
                  import_resource "module.app.module.ca_jobs[0].azurerm_container_app.this" \
                                  "$CA_ID" \
                                  "Container App (Jobs)"
                  ;;
              esac
            done
          fi
          
          echo "‚úÖ Resource import process completed"
          
      - name: ‚úÖ Terraform Validate
        if: inputs.action == 'validate' || inputs.action == 'plan' || inputs.action == 'apply'
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "‚úÖ Validating Terraform configuration..."
          terraform validate -no-color
          echo "‚úÖ Terraform configuration is valid"
          
      - name: üìã Terraform Plan
        if: inputs.action == 'plan' || inputs.action == 'apply'
        id: plan
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "üìã Generating Terraform execution plan..."
          
          PLAN_ARGS="-var-file=${{ env.TF_VAR_FILE }} -no-color -detailed-exitcode"
          
          # Add target resources if specified
          if [[ -n "${{ inputs.target_resources }}" ]]; then
            for resource in $(echo "${{ inputs.target_resources }}" | tr ',' ' '); do
              PLAN_ARGS="$PLAN_ARGS -target=$resource"
            done
            echo "üéØ Targeting specific resources: ${{ inputs.target_resources }}"
          fi
          
          # Save plan to file for apply step
          if terraform plan $PLAN_ARGS -out=tfplan; then
            echo "‚úÖ Terraform plan generated successfully"
            echo "status=success" >> $GITHUB_OUTPUT
            
            # Show plan summary
            terraform show -no-color tfplan
          else
            PLAN_EXIT_CODE=$?
            if [[ $PLAN_EXIT_CODE -eq 2 ]]; then
              echo "üìù Plan generated with changes"
              terraform show -no-color tfplan
              echo "status=changes" >> $GITHUB_OUTPUT
            else
              echo "‚ùå Terraform plan failed"
              echo "status=failed" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi
          
      - name: üöÄ Terraform Apply
        if: inputs.action == 'apply'
        id: apply
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "üöÄ Applying Terraform changes..."
          
          APPLY_ARGS="-no-color"
          
          # Handle auto-approve
          if [[ "${{ inputs.auto_approve }}" == "true" ]]; then
            echo "‚ö° Auto-approve enabled - applying without confirmation"
            APPLY_ARGS="$APPLY_ARGS -auto-approve"
          fi
          
          # Apply using the saved plan
          if terraform apply $APPLY_ARGS tfplan; then
            echo "‚úÖ Terraform apply completed successfully"
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Terraform apply failed"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
      - name: üí• Terraform Destroy
        if: inputs.action == 'destroy'
        id: destroy
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "üí• Destroying Terraform-managed infrastructure..."
          
          # Security check for production
          if [[ "${{ inputs.environment }}" == "prod" && "${{ inputs.auto_approve }}" != "true" ]]; then
            echo "‚ùå Destroy operations in production require auto_approve=true for safety"
            echo "‚ùå This prevents accidental destruction of production resources"
            exit 1
          fi
          
          DESTROY_ARGS="-var-file=${{ env.TF_VAR_FILE }} -no-color"
          
          # Add target resources if specified
          if [[ -n "${{ inputs.target_resources }}" ]]; then
            for resource in $(echo "${{ inputs.target_resources }}" | tr ',' ' '); do
              DESTROY_ARGS="$DESTROY_ARGS -target=$resource"
            done
            echo "üéØ Targeting specific resources: ${{ inputs.target_resources }}"
          fi
          
          # Handle auto-approve
          if [[ "${{ inputs.auto_approve }}" == "true" ]]; then
            echo "‚ö° Auto-approve enabled - destroying without confirmation"
            DESTROY_ARGS="$DESTROY_ARGS -auto-approve"
          fi
          
          if terraform destroy $DESTROY_ARGS; then
            echo "‚úÖ Terraform destroy completed successfully"
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Terraform destroy failed"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
      - name: üìä Capture Terraform Outputs
        if: (inputs.action == 'apply' || inputs.action == 'plan') && steps.apply.outputs.status == 'success'
        id: outputs
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "üìä Capturing Terraform outputs..."
          
          # Capture API URL if available
          API_URL=$(terraform output -raw api_url 2>/dev/null || echo "")
          if [[ -n "$API_URL" ]]; then
            echo "api_url=$API_URL" >> $GITHUB_OUTPUT
            echo "üåê API URL: $API_URL"
          fi
          
          # Generate deployment summary
          {
            echo "## üöÄ Deployment Summary"
            echo ""
            echo "- **Environment**: ${{ inputs.environment }}"
            echo "- **Action**: ${{ inputs.action }}"
            echo "- **Status**: ‚úÖ Success"
            echo "- **Timestamp**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            
            if [[ -n "$API_URL" ]]; then
              echo "- **API URL**: [$API_URL]($API_URL)"
            fi
            
            if [[ -n "${{ inputs.target_resources }}" ]]; then
              echo "- **Target Resources**: ${{ inputs.target_resources }}"
            fi
            
            echo ""
            echo "### üìã Next Steps"
            if [[ "${{ inputs.environment }}" == "dev" && -n "$API_URL" ]]; then
              echo "- üß™ Test your API using Postman: \`TripRadar Dev Azure Environment\`"
              echo "- üìä Monitor application: [Azure Portal](https://portal.azure.com/#@/resource/subscriptions/${{ env.ARM_SUBSCRIPTION_ID }}/resourceGroups/${{ needs.validate-environment.outputs.resource_group_name }})"
            fi
          } >> $GITHUB_STEP_SUMMARY
          
      - name: üßπ Cleanup on Failure
        if: failure()
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "üßπ Cleaning up after failure..."
          
          # Clean up any lock files or temporary files
          rm -f .terraform.lock.hcl tfplan terraform.tfplan
          
          # Log failure information
          {
            echo "## ‚ùå Deployment Failed"
            echo ""
            echo "- **Environment**: ${{ inputs.environment }}"
            echo "- **Action**: ${{ inputs.action }}"
            echo "- **Timestamp**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo ""
            echo "Please check the workflow logs for detailed error information."
          } >> $GITHUB_STEP_SUMMARY
          
      - name: üîê Azure Logout
        if: always()
        run: |
          if az account show >/dev/null 2>&1; then
            az logout
            echo "‚úÖ Successfully logged out from Azure CLI"
          else
            echo "‚ÑπÔ∏è No active Azure CLI session to logout"
          fi
